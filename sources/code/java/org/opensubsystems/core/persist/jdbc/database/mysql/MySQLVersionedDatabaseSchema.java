/*
 * Copyright (C) 2003 - 2013 OpenSubsystems.com/net/org and its owners. All rights reserved.
 * 
 * This file is part of OpenSubsystems.
 *
 * OpenSubsystems is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>. 
 */

package org.opensubsystems.core.persist.jdbc.database.mysql;

import java.sql.Connection;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Logger;
import java.util.logging.Level;

import org.opensubsystems.core.error.OSSException;
import org.opensubsystems.core.persist.jdbc.impl.DatabaseImpl;
import org.opensubsystems.core.persist.jdbc.impl.VersionedDatabaseSchemaImpl;
import org.opensubsystems.core.util.Log;
import org.opensubsystems.core.util.jdbc.DatabaseUtils;

/**
 * Database specific operations related to persistence of database schemas in 
 * MySQL.
 *
 * @author OpenSubsystems
 */
public class MySQLVersionedDatabaseSchema extends VersionedDatabaseSchemaImpl
{
   /*
      Use autogenerated numbers for IDs using IDENTITY column.
      Identity automatically defines primary key
      Name all constraints to easily identify them later.
      For all unique constraint we need to define unique indexes instead of 
      unique constraint otherwise we won't be able to identify the violation of
      this constraint by name. 
      DESCRIPTION column must be type of TEXT because VARCHAR type 
      can be max. 255 characters length.
      All TIMESTAMP columns have to have constant default values otherwise MySQL
      will automatically update them with current timestamp every time record
      is modified.

      CREATE TABLE BF_SCHEMA
      (
         ID INTEGER NOT NULL AUTO_INCREMENT,
         SCHEMA_NAME VARCHAR(50) NOT NULL,
         SCHEMA_VERSION INTEGER NOT NULL,
         CREATION_DATE TIMESTAMP NOT NULL DEFAULT 0,
         MODIFICATION_DATE TIMESTAMP NOT NULL DEFAULT 0,
         CONSTRAINT BF_SCH_PK PRIMARY KEY (ID),
         CONSTRAINT BF_SCH_UQ UNIQUE (SCHEMA_NAME)
      ) TYPE=INNODB
   
      CREATE INDEX IND_BF_SCHEMA_MODIFICATION_DATE ON BF_SCHEMA (MODIFICATION_DATE);

   */
   // Cached values ////////////////////////////////////////////////////////////

   /**
    * Logger for this class
    */
   private static Logger s_logger = Log.getInstance(MySQLVersionedDatabaseSchema.class);

   // Constructors /////////////////////////////////////////////////////////////
   
   /**
    * @throws OSSException - database cannot be started.
    */
   public MySQLVersionedDatabaseSchema(
   ) throws OSSException
   {
      super();
   }
   
   /**
    * {@inheritDoc}
    */
   @Override
   public void create(
      Connection cntDBConnection, 
      String     strUserName
   ) throws SQLException
   {
      s_logger.entering(this.getClass().getName(), "create");

      try
      {
         Statement stmQuery = null;
         try
         {
            stmQuery = cntDBConnection.createStatement();
            if (stmQuery.execute(
               "create table " + SCHEMA_TABLE_NAME + NL +
               "(" + NL +
               "   ID INTEGER NOT NULL AUTO_INCREMENT," + NL +
               "   SCHEMA_NAME VARCHAR(" + SCHEMA_NAME_MAXLENGTH + ") NOT NULL," + NL +
               "   SCHEMA_VERSION INTEGER NOT NULL," + NL +
               "   CREATION_DATE TIMESTAMP NOT NULL DEFAULT 0," + NL +
               "   MODIFICATION_DATE TIMESTAMP NOT NULL DEFAULT 0," + NL +
               "   CONSTRAINT " + getSchemaPrefix() + "SCH_PK PRIMARY KEY (ID)," + NL +
               "   CONSTRAINT " + getSchemaPrefix() + "SCH_UQ UNIQUE (SCHEMA_NAME)" + NL +
               ") TYPE=INNODB"))
            {
               // Close any results
               stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
            }
            s_logger.log(Level.FINEST, "Table {0} created.", SCHEMA_TABLE_NAME);

            ///////////////////////////////////////////////////////////////////////

            if (stmQuery.execute("CREATE INDEX IND_" + SCHEMA_TABLE_NAME 
                                 + "_MODIFICATION_DATE " + "ON " 
                                 + SCHEMA_TABLE_NAME + " (MODIFICATION_DATE)"))
            {
               // Close any results
               stmQuery.getMoreResults(Statement.CLOSE_ALL_RESULTS);
            }
            s_logger.log(Level.FINEST, "Index IND_{0}_MODIFICATION_DATE created.", 
                         SCHEMA_TABLE_NAME);

            ///////////////////////////////////////////////////////////////////////
         }
         catch (SQLException sqleExc)
         {
            // Catch this just so we can log the message
            s_logger.log(Level.WARNING, "Failed to create version schema.",
                                sqleExc);
            throw sqleExc;
         }
         finally
         {
            DatabaseUtils.close(stmQuery);
         }
      }
      finally
      {
         s_logger.exiting(this.getClass().getName(), "create");
      }
   }

   /**
    * Method returns simple insert user query. This method is common for all
    * databases and can be overwritten for each specific database schema.
    *
    * @return String - simple insert schema query
    * @throws OSSException - exception during getting query
    */
   @Override
   public String getInsertSchema(
   ) throws OSSException
   {
      StringBuilder buffer = new StringBuilder();
      
      buffer.append("insert into " + SCHEMA_TABLE_NAME 
                    + " (ID, SCHEMA_NAME, SCHEMA_VERSION,"
                    + " CREATION_DATE, MODIFICATION_DATE)"
                    + " values (null,?,?,");
      buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
      buffer.append(",");
      buffer.append(DatabaseImpl.getInstance().getSQLCurrentTimestampFunctionCall());
      buffer.append(")");

      return buffer.toString();
   }
}
